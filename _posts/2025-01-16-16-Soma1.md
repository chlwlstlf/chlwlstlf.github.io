---
layout: single
title: "[BOJ]16기 SW마에스트로 1차 코테대비"
categories: boj
toc: true
toc_sticky: true
---

# Coding Test Study 2025 Soma1

## 💻20250116 (실3~실1)

**1\. 모든 순열 (실3)**
[10974](https://www.acmicpc.net/problem/10974)

<div class="blue-box">
  <p>
    <b>백트래킹</b>
    <div>• answer의 길이가 N이 되면 출력</div>
    <div>• 1부터 N까지 돌리면서 answer에 추가와 제거를 반복하면 된다.</div>
  </p>
</div>

<script src="https://gist.github.com/chlwlstlf/a714ba79788ffb418e81e1686202a5ed.js"></script>

<br>

**2\. 단어 뒤집기 2 (실3)**
[17413](https://www.acmicpc.net/problem/17413)

<div class="blue-box">
  <p>
    <b>문자열, 스택</b>
    <div>• "<"이면 stack에 넣고 word가 있다면 뒤집어서 출력한다.</div>
    <div>• stack이 있으면 문자열을 그대로 출력한다.</div>
    <div>• stack이 비어 있고 공백이면 뒤집어서 출력하고, 글자이면 word에 추가한다.</div>
    <div>• ">"이면 stack을 비운다.</div>
  </p>
</div>

<script src="https://gist.github.com/chlwlstlf/6a3ee9e9911fe770e22a3c12f65f64a8.js"></script>

<br>

**3\. 카잉 달력 (실1)**
[6064](https://www.acmicpc.net/problem/6064)

<div class="blue-box">
  <p>
    <b>수학</b>
    <div>• 마지막 해는 M과 N의 최소공배수이다.</div>
    <div>• i를 0부터 하나씩 늘려가면서 mod로 x와 y에 해당하는 값을 찾을 수 있다.</div>
    <div>• M*i+x가 최소공배수가 커도 -1을 출력해야 한다.</div>
  </p>
</div>

<script src="https://gist.github.com/chlwlstlf/a44ecfe898ffde7d79129ccab7fcea19.js"></script>

<br>
<br>

## 💻20250118 (골4)

**1\. 여행 가자 (골4)**
[1976](https://www.acmicpc.net/problem/1976)

<div class="blue-box">
  <p>
    <b>DFS</b>
    <div>• 유니온 파인드로도 풀 수 있는 문제이다.</div>
    <div>• 여행 계획 도시 정보를 [1, 2, 3, 2, 3]으로 입력했다면 set_order에는 {(1, 2), (2, 3)}만 저장된다. [1-2, 2-3, 3-2, 2-3]에서 중복되는 것을 제거했다.</div>
  </p>
</div>

<script src="https://gist.github.com/chlwlstlf/a6592143ee898bf5d882ae18660ca313.js"></script>

<br>
<br>

## 💻20250119 (골3)

**1\. 욕심쟁이 판다 (골3)**
[1937](https://www.acmicpc.net/problem/1937)

<div class="blue-box">
  <p>
    <b>DFS+DP</b>
    <div>• 한 번 갔던 경로는 중복이므로 DP에 그 지점부터 갈 수 있는 최대 칸 수를 저장하여 풀 수 있다.</div>
    <div>• 예를 들어 2→3→4→5 경로를 계산한 후 그 다음 1→2로 갔다면 2에서 갈 수 있는 최대 칸 수를 다시 계산하지 않아도 된다.</div>
  </p>
</div>

시작 지점과 dp 테이블 출력 결과

```
시작 지점: 0 0
1 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0

시작 지점: 0 1
1 3 1 0
0 2 0 0
0 1 0 0
0 0 0 0

시작 지점: 0 3
1 3 1 2
0 2 0 0
0 1 0 0
0 0 0 0

시작 지점: 1 0
1 3 1 2
3 2 0 0
2 1 0 0
0 0 0 0

시작 지점: 1 2
1 3 1 2
3 2 3 0
2 1 0 0
0 0 0 0

시작 지점: 1 3
1 3 1 2
3 2 3 4
2 1 0 1
0 0 0 0

시작 지점: 2 2
1 3 1 2
3 2 3 4
2 1 4 1
0 0 1 0

시작 지점: 3 0
1 3 1 2
3 2 3 4
2 1 4 1
3 0 1 0

시작 지점: 3 1
1 3 1 2
3 2 3 4
2 1 4 1
3 4 1 0

시작 지점: 3 3
1 3 1 2
3 2 3 4
2 1 4 1
3 4 1 2
```

<script src="https://gist.github.com/chlwlstlf/9e99ce35186e1c2696ac6d14162a9cdf.js"></script>

<br>
<br>

## 💻20250120 (골2)

**1\. 빵집 (골2)**
[3109](https://www.acmicpc.net/problem/3109)

<div class="blue-box">
  <p>
    <b>그리디+DFS</b>
    <div>• 그리디인 이유는 [-1, 0, 1]으로 탐색해야 하기 때문이다. 그 외의 이유는 없어 보인다.</div>
    <div>• 다음으로 갈 수 있으면 "x"로 변경한 후 dfs를 돌린다. 이때 dfs가 마지막 지점에 도달해서 True이면 더이상 dfs를 할 필요가 없고, 다시 루트까지 True를 반환하게 해야 하므로 16, 17줄 조건문을 추가해준다.</div>
  </p>
</div>

어떤 행이 도착 지점까지 가는지 확인

```
0 x x . 0
. 0 x 0 .
. . 0 . .
. . . x .
. . . x .

0 x x . 0
1 0 x 0 1
. 1 0 1 .
. . 1 x .
. . . x .

0 x x . 0
1 0 x 0 1
2 1 0 1 .
. 2 1 x .
. . 2 x .

0 x x . 0
1 0 x 0 1
2 1 0 1 .
3 2 1 x .
. 3 2 x .

0 x x . 0
1 0 x 0 1
2 1 0 1 .
3 2 1 x .
4 3 2 x .
```

<script src="https://gist.github.com/chlwlstlf/02fad81489da1a11735f0e46e89f5719.js"></script>
