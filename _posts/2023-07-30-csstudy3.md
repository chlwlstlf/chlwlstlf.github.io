---
layout: archive
title: "[3] 운영체제"
categories: CS
toc: true
toc_sticky: true
---

# 면접을 위한 CS 전공지식 노트 CHAPTER 3

---

# SECTION 3.1 운영체제와 컴퓨터

## <mark style='background-color: #ffdce0'>3.1.1 운영체제의 역할과 구조</mark>

1\. 운영체제 역할

- CPU 스케줄링와 프로세스 관리
- 메모리 관리
- 디스크 파일 관리
- I/O 디바이스 관리

2\. 운영체제 구조  
![KakaoTalk_20230804_145556264](https://github.com/chlwlstlf/data/assets/63334368/05ac9501-29fa-4a36-9b21-73223c65ebc1)

<mark style='background-color: #fff5b1'>1) GUI</mark>

- 사용자가 전자장치와 상호 작용할 수 있도록 하는 사용자 인터페이스의 한 형태
- 단순 명령어 창이 아닌 아이콘을 마우스로 클릭하는 단순한 동작으로 컴퓨터와 상호 작용할 수 있도록 해줌

<mark style='background-color: #fff5b1'>2) 시스템콜</mark>

- 운영체제가 커널에 접근하기 위한 인터페이스
- 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 씀
- 커널 모드에서 파일을 읽고 유저모드로 돌아감
- 컴퓨터 자원에 대한 직접 접근 차단, 보호

<div style="padding: 15px; border: 1px solid transparent; border-color: transparent; margin-bottom: 20px; border-radius: 4px; color: #31708f; background-color: #d9edf7; border-color: #bce8f1;">
  <p> modebit </p>   
  <div>- 유저 모드와 커널 모드를 구분할 수 있음</div>
	<div>- 0: 커널 모드 / 1: 유저 모드</div>
  <div>- 유저가 프로그램 킴 → 시스템콜 호출 → modebit 0으로(커널) → 카메라 자원 로직 수행 → modebit 1로(유저)</div>
</div>

<mark style='background-color: #fff5b1'>3) 커널</mark>

- 운영체제의 핵심 부분, 인터페이스 제공
- 보안, 메모리, 프로세스, 파일 시스템, I/O 디바이스, I/O 요청 관리 등

<mark style='background-color: #fff5b1'>4) 드라이버</mark>

- 하드웨어를 제어하기 위한 소프트웨어

---

## <mark style='background-color: #ffdce0'>3.1.2 컴퓨터의 요소</mark>

![KakaoTalk_20230804_145556264_01](https://github.com/chlwlstlf/data/assets/63334368/57b689b9-597d-4714-9027-3d6005343aaf)

<mark style='background-color: #fff5b1'>1) CPU</mark>

> 메모리에 존재하는 명령어 해석•실행

✏️ 제어장치  
프로세스 조작 지시, 입출력장치 간 통신 제어, 명령어 해석, 데이터 처리 순서 결정

✏️ 레지스터  
임시기억장치, 연산 속도 매우 빠름

✏️ 산술논리연산장치  
산술 연산+논리 연산

<div style="padding: 15px; border: 1px solid transparent; border-color: transparent; margin-bottom: 20px; border-radius: 4px; color: #31708f; background-color: #d9edf7; border-color: #bce8f1;">
  <p> CPU 연산 처리 </p>  
  <div>1. 제어장치가 메모리와 레지스터에 계산할 값 로드</div>
	<div>2. 제어장치가 산술논리연산장치에 계산하라고 명령</div>
  <div>3. 레지스터에서 메모리로 계산한 값 저장</div>
</div>

✏️ 인터럽트

> CPU 잠깐 정지  
> 우선순위에 따라 실행

- 하드웨어 인터럽트: IO 디바이스에서 발생, 순차적인 실행 중지, 운영체제에 시스템콜 요청해서 디바이스 로컬 버퍼에 접근
- 소프트웨어 인터럽트: '트랩', 프로세스 오류

<mark style='background-color: #fff5b1'>2) DMA 컨트롤러 </mark>

- I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치
- CPU 부하 막아줌
- CPU와 DMA 컨트롤러 동시 작업 막아줌

<mark style='background-color: #fff5b1'>3) 메모리 </mark>

- RAM, 데이터나 상태 기록

<mark style='background-color: #fff5b1'>4) 타이머 </mark>

- 시간 제한

<mark style='background-color: #fff5b1'>5) 디바이스 컨트롤러 </mark>

- IO 디바이스들의 작은 CPU
- 로컬 버퍼: 디바이스들의 작은 메모리

---

# SECTION 3.2 메모리

## <mark style='background-color: #ffdce0'>3.2.1 메모리 계층</mark>

![KakaoTalk_20230804_145556264_02](https://github.com/chlwlstlf/data/assets/63334368/b8e84056-b5b7-42d8-a072-8daca8fbcfa5)

※ 로딩중: 하드디스크 → RAM으로 전송중

<mark style='background-color: #fff5b1'>1) 레지스터 </mark>

CPU 안에 있는 작은 메모리, 휘발성

<mark style='background-color: #fff5b1'>2) 캐시 </mark>

L1, L2 (L3) 캐시, 휘발성, 병목 현상 줄이는 메모리

<div style="padding: 15px; border: 1px solid transparent; border-color: transparent; margin-bottom: 20px; border-radius: 4px; color: #31708f; background-color: #d9edf7; border-color: #bce8f1;">
  <p> 지역성 </p>  
  <div>자주 사용하는 데이터 판단 근거</div>
	<div>시간 지역성: 최근 사용한 데이터(for문 i+1)</div>
  <div>공간 지역성: 최근 접근한 데이터 공간(arr)</div>
</div>

✏️ 캐시히트  
데이터가 캐시에 있을 때, 제어장치에서 데이터 가져옴(CPU 내부 버스)

※ 캐시매핑: 캐시가 히트되기 위해 매핑

|      이름      |       설명       |   장점    |   단점    |
| :------------: | :--------------: | :-------: | :-------: |
|   직접 매핑    |  1:1~10, 2:1~20  |   빠름    | 충돌 잦음 |
|   연관 매핑    |    순서 일치x    |   느림    | 충돌 적음 |
| 집합 연관 매핑 | 순서 일치&블록화 | 검색 효율 |     x     |

---

※ 웹 브라우저 캐시

|     이름      |                설명                 |
| :-----------: | :---------------------------------: |
|     쿠키      |        만료기한이 있는 키-값        |
| 로컬 스토리지 | 만료기한이 있는 키-값, 닫아도 유지  |
| 세션 스토리지 | 만료기한이 있는 키-값, 닫을 때 삭제 |

✏️ 캐시미스  
데이터가 캐시에 없을 때, 메모리에서 데이터 가져옴(시스템 버스)

<mark style='background-color: #fff5b1'>3) 주기억장치 </mark>

RAM, 휘발성

<mark style='background-color: #fff5b1'>4) 보조기억장치 </mark>

HDD, SSD, 비휘발성

## <mark style='background-color: #ffdce0'>3.2.2 메모리 관리</mark>

<mark style='background-color: #fff5b1'>1) 가상 메모리 </mark>

> - 메모리관리장치(MMU)에 의해 실제 주소로 변환
> - 페이지 테이블로 관리됨
> - TLB: 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시, 페이지 테이블에 있는 리스트 보관, 속도 향상

✏️ 스와핑  
가상 메모리에는 존재하지만 RAM에는 현재 없는 데이터나 코드에 접근할 때  
당장 사용하지 않는 영역을 하드디스크로 옮기고 하드디스크의 일부분을 마치 메모리처럼 불러와 쓰는 것

✏️ 페이지 폴트

1. CPU가 물리 메모리 확인 → 해당 페이지 없으면 트랩, 운영체제에 알림
2. 운영체제가 CPU 잠시 멈춤
3. 가상 메모리에 페이지 존재 확인 → 없으면 중단, 물리 메모리에서 찾음 → 없으면 스와핑
4. 비어 있는 프레임에 해당 페이지 로드, 페이지 테이블 최신화
5. CPU 다시 시작

<mark style='background-color: #fff5b1'>2) 스레싱 </mark>

메모리의 페이지 폴트율이 높은 것, 성능 저하  
해결 방법: 메모리 늘리거나, HDD → SSD, 작업 세트, PFF

✏️ 작업 세트  
지역성으로 결정된 페이지 집합을 만들어서 미리 메모리에 로드  
장점: 탐색 비용↓, 스와핑↓

✏️ PFF  
페이지 폴트 빈도 조절, 상한선•하한선

<mark style='background-color: #fff5b1'>3) 메모리 할당 </mark>

✏️ 연속 할당

1\. 고정 분할 방식  
메모리 미리 나눔, 융통성x, 내부 단편화(작은 공간들이 많이 낭비되는 것)

2\. 가변 분할 방식  
프로그램 크기에 맞게 동적으로 메모리 나눔, 외부 단편화(작업보다 큰 공간이 남아도 나눠져 있어서 못 들어가는 것)

|   이름   |                  설명                   |
| :------: | :-------------------------------------: |
| 최초적합 | 한쪽부터 시작해서 홀을 찾으면 바로 할당 |
| 최적적합 |  적합한 크기 중 가장 작은 홀부터 할당   |
| 최악적합 | 크기와 가장 많이 차이가 나는 홀에 할당  |

✏️ 불연속 할당(현대)

1\. 페이징  
동일한 페이지 단위, 다른 위치에 할당  
장점: 홀 크기 균일  
단점: 주소 변환 복잡

2\. 세그멘테이션  
세그먼트로 나눔, 코드•데이터•작은 함수 등으로 나눌 수 있음  
장점: 공유, 보안 좋음
단점: 홀 크기 다름

3\. 페이지드 세그멘테이션  
프로그램을 의미 단위인 세그먼트로 나눔 + 동일한 크기의 페이지 단위로 나눔

<mark style='background-color: #fff5b1'>4) 페이지 교체 알고리즘 </mark>

✏️ 오프라인 알고리즘

- 미래의 것과 교체, 가장 좋고 이상적임
- 다른 알고리즘과의 성능 비교에 대한 상한기준 제공

✏️ FIFO

- First In First Out
- 가장 먼저 온 페이지 교체

✏️ LRU

- Lest Recentle Used
- 참조가 가장 오래된 페이지 교체
- 계수기, 스택 두어야 함

✏️ NUR

- Not Used Recently
- 참조되지 않은 페이지 교체

✏️ LFU

- Least Frequently Used
- 가장 참조 횟수가 적은 페이지 교체

# SECTION 3.3 프로세스와 스레드

> 프로세스: 컴퓨터에서 실행되고 있는 프로그램(=task)  
> 스레드: 프로세스 내 작업의 흐름

## <mark style='background-color: #ffdce0'>3.3.1 프로세스와 컴파일 과정</mark>

프로세스(구글 크롬): 프로그램(chrome.exe)이 메모리에 올라가 인스턴스화 된 것

※ 과정(c언어)  
![KakaoTalk_20230804_145556264_03](https://github.com/chlwlstlf/data/assets/63334368/1c5ff87f-46a8-437a-b958-60bd004f3ad7)

✏️ 전처리  
주석 제거, 헤더 파일 병합, 메크로 치환

✏️ 컴파일러  
오류 처리, 코드 최적화 작업, 어셈블리어로 변환

✏️ 어셈블러  
어셈블리어는 목적 코드로 변환, 확장자 변환

✏️ 링커  
함수 또는 다른 파일들과 목적 코드를 결합하여 실행 파일을 만듦, 확장자는 .exe 또는 .out

## <mark style='background-color: #ffdce0'>3.3.2 프로세스의 상태</mark>

![KakaoTalk_20230804_145556264_04](https://github.com/chlwlstlf/data/assets/63334368/6e98cb1a-0674-4504-9fbd-2be6143a7aed)

|      상태      |                             설명                             |
| :------------: | :----------------------------------------------------------: |
|   생성 상태    |            프로세스가 생성된 상태, fork(), exec()            |
|   대기 상태    | 메모리 공간 충분 → 메모리 할당 / x → 대기, CPU 소유권 기다림 |
| 대기 중단 상태 |                  메모리 부족으로 일시 중단                   |
|   실행 상태    |      CPU 소유권과 메모리 할당 받음, 인스트럭션 수행 중       |
|   중단 상태    |      프로세스 차단된 상태, I/O 디바이스에 의한 인터럽트      |
| 일시 중단 상태 |                 대기 중단 유사, 메모리 부족                  |
|   종료 상태    |               메모리와 CPU 소유권 모두 놓고 감               |

## <mark style='background-color: #ffdce0'>3.3.3 프로세스의 메모리 구조</mark>

✏️ 동적 영역(스택, 힙)  
스택: 메모리 영역, 특징 정보 계속 저장  
힙: 변수 담음

✏️ 정적 영역(데이터 영역, 코드 영역)

> 컴파일 단계에서 메모리 할당
> 데이터 영역: BSS segment(0), Data segment(0 아닌 값), code/text segment(프로그램 코드)

## <mark style='background-color: #ffdce0'>3.3.4 PCB</mark>

> - Process Control Block
> - 운영체제에서 프로세스에 대한 메타데이터를 저장한 데이터
> - 중요한 정보, 커널 스택의 가장 앞부분

---

✏️ PCB 구조

- 프로세스 스케줄링 상태: 프로세스가 CPU에 대한 소유권을 얻은 이후의 상태
- 프로세스 ID
- 프로세스 권한
- 프로그램 카운터
- CPU 레지스터
- CPU 스케줄링 정보: 중단된 시간 등
- 계정 정보: CPU 사용량, 유저 정보
- I/O 상태 정보

---

✏️ 컨텍스트 스위칭

> - PCB를 교환하는 과정
> - 싱글코어: 어떠한 시점에서 실행되고 있는 프로세스는 한 개
> - 동시x, 컨텍스트 스위칭이 아주 빠르게 실행됨

![KakaoTalk_20230804_145556264_05](https://github.com/chlwlstlf/data/assets/63334368/eebde8ab-bc1e-40f7-9d24-e3a4e37b0c19)

1. A가 실행하다 멈춤
2. A의 PCB를 저장하고 다시 B를 로드하여 실행
3. 유휴 시간, 비용(캐시미스) 발생

## <mark style='background-color: #ffdce0'>3.3.5 멀티프로세싱</mark>

> - 여러 개의 '프로세스'로 두 가지 이상의 일 수행 가능
> - 병렬로 처리
> - 장점: 하나 문제 발생돼도 다른 프로세스에서 처리 가능, 신뢰성↑

<mark style='background-color: #fff5b1'>웹 브라우저 </mark>

- 브라우저 프로세스: 네트워크 요청이나 파일 접근(주소 표시줄, 북마크 막대, 이전 버튼)
- 렌더러 프로세스: '보이는' 모든 부분
- 플러그인 프로세스: 플러그인 제어
- GPU 프로세스: GPU 제어

---

<mark style='background-color: #fff5b1'> IPC </mark>

> - Inter Process Communication
> - 공유 데이터를 관리하는 메커니즘
> - 클라: 데이터 요청 / 서버: 데이터 응답
> - 공유 스레드보다 속도 떨어짐
> - 6종류

✏️ 1. 공유 메모리

- 여러 프로세스에 동일한 메모리 블록에 대한 접근 권한 부여
- 메모리 자체 공유 → 불필요한 데이터 복사의 오버헤드x
- 가장 빠름, 동기화 필요

✏️ 2. 파일

- 디스크에 저장된 데이터, 파일 서버에서 제공한 데이터

✏️ 3. 소켓

- 네트워크 인터페이스를 통해 전송하는 데이터
- TCP, UDP

✏️ 4. 익명 파이프

- FIFO 방식
- 파이프: 임시 공간
- 단방향 방식의 읽기 전용, 쓰기 전용 파이프

✏️ 5. 명명된 파이프

- 단방향, 양방향 파이프
- 여러 파이프 동시에 사용 가능

✏️ 6. 메시지 큐

- 메시지를 큐 데이터 구조 형태로 관리
- 커널에서 전역적으로 관리됨
- 직관적, 코드 수정x

## <mark style='background-color: #ffdce0'>3.3.6 스레드와 멀티스레딩</mark>

<mark style='background-color: #fff5b1'> 스레드 </mark>

> - 프로세스의 실행 가능한 가장 작은 단위
> - 프로세스는 여러 스레드를 가질 수 있음

<mark style='background-color: #fff5b1'> 멀티스레딩 </mark>

> - 스레드끼리 서로 자원 공유, 효율성↑
> - 한 스레드가 중단돼도 다른 스레드 실행 가능, 영향은 줄 수 있음

## <mark style='background-color: #ffdce0'>3.3.7 공유 자원과 임계 영역</mark>

<mark style='background-color: #fff5b1'> 공유자원 </mark>

> - 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 모든 자원이나 변수
> - 경쟁 상태: 여러개의 프로세스가 동시에 접근하는 상태
> - 타이밍, 순서가 영향 줌

<mark style='background-color: #fff5b1'> 임계 영역 </mark>

> - 동시에 접근할 때 순서 등의 이유로 결과가 달라지는 코드 영역
> - 3가지 방법(뮤텍스, 세마포어, 모니터)
> - 3가지 조건(상호 배제, 한정 대기, 융통성)

✏️ 1. 뮤텍스

- 공유자원을 lock()을 통해 잠금 설정
- 사용한 후에는 unlock()을 동해 잠금 해제
- 잠긴 코드 영역에 접근x

✏️ 2. 세마포어

- 일반화된 뮤텍스
- wait(): 자신의 차례가 올 때까지 기다리는 함수
- signal(): 다음 프로세스로 순서를 넘겨주는 함수

✏️ 3. 모니터

- 공유자원을 숨기고, 해당 접근에 대해 인터페이스만 제공

## <mark style='background-color: #ffdce0'>3.3.8 교착 상태</mark>

> - 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태

<mark style='background-color: #fff5b1'> 원인 </mark>

- 상호 배제: 자원 독점, 다른 건 접근 불가능ㅋ
- 점유 대기: 다른 프로세스가 요청하는 상태
- 비선점: 자원 강제적으로 가져오는 거 불가능
- 환형 대기: 서로의 자원을 요구하는 상황

<mark style='background-color: #fff5b1'> 해결 방법 </mark>

1\. 애초에 조건이 성립되지 않게 설계
2\. 교착 상태 가능성이 없을 떄만 자원 할당, 은행원 알고리즘
3\. 사이클 있는지 찾아보고 하나씩 지움
4\. 처리 비용이 크기 때문에 사용자가 작업 종료('응답 없음')

# SECTION 3.4 CPU 스케줄링 알고리즘

## <mark style='background-color: #ffdce0'>3.4.1 비선점형 방식</mark>

> - 프로세스가 스스로 CPU 소유권을 포기하는 방식(강제X)
> - 컨텍스트 스위칭으로 인한 부하 적음

<mark style='background-color: #fff5b1'> FCFS </mark>

- First Come, First Served
- 단점: 준비 큐에서 오래 기다리는 현상

<mark style='background-color: #fff5b1'> SJF </mark>

- Shortest Job First
- 단점: 긴 시간을 가진 프로세스가 실행되지 않는 현상
- 장점: 평균 대기 시간 가장 짧음

<mark style='background-color: #fff5b1'> 우선순위 </mark>

- aging: 오래된 작업일수록 우선순위 높임

## <mark style='background-color: #ffdce0'>3.4.2 선점형 방식</mark>

> - 현재 채택한 방식
> - 강제 중단, 다른 프로세스에 CPU 소유권 할당

<mark style='background-color: #fff5b1'> 우선순위 </mark>

- 현대에 사용 중
- 동일한 할당 시간, 끝나지 않으면 다시 준비 큐
- 할당시간 너무 크면 FCFS, 너무 짧으면 컨텍스트 스위칭이 잦아짐

<mark style='background-color: #fff5b1'> SRF </mark>

- 중간에 더 짧은 작업이 들어오면 수행 바꿈

<mark style='background-color: #fff5b1'> 다단계 큐 </mark>

- 우선순위에 따른 준비 큐를 여러 개 사용
- 큐마다 다른 알고리즘
