---
layout: single
title:  "DFS & BFS"
categories: CodingTest
toc: true
---

# Coding Test 3

[이코테 3](https://www.youtube.com/watch?v=7C9RgOcvkvo&list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC&index=3){: .btn .btn--primary}

# 미리 알아야 할 자료구조
1. 스택
    - 먼저 들어 온 데이터가 나중에 나가는 형식(선입후출)의 자료구조이다.
    - 입구와 출구가 동일한 형태로 스택을 시각화 할 수 있다.

    ```python
    stack = []

    stack.append(5)
    stack.pop()
    ```

2. 큐
    - 먼저 들어 온 데이터가 먼저 나가는 형식(선입선출)의 자료구조이다.
    - 큐는 입구와 출구가 모두 뚫려 있는 터널과 같은 형태로 시각화 할 수 있다.

    ```python
    from collections import deque

    queue = deque()

    queue.append(5)
    queue.popleft()
    ```

3. 재귀함수
- 자기 자신을 다시 호출하는 함수

## 문제1-팩토리얼
    ```python
    def factorial(n) :
        if n <= 1 :
            return 1
        return n * factorial(n-1)
    
    print(factorial(5))
    ```

## 문제2-최대공약수(유클리드 호제법)
    ```python
    def gcd(a, b) :
        if a % b == 0 :
            return b
        return gcd(b, a%b)
    
    print(gcd(192, 162))
    ```


# <mark style='background-color: #ffdce0'> 1. DFS </mark>  
- <mark style='background-color: #fff5b1'>깊이 우선 탐색</mark>, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘
- 스택 자료구조(혹은 재귀 함수)를 이용
    1. 탐색 시작 노드를 스택에 삽입하고 방문 처리
    2. 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문처리
        방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냄
    3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복
- 동작 예시
    [Step 0] 시작 노드 : 1 (방문 기준 : 번호가 낮은 인접 노드부터)

    [Step 1] 시작 노드인 '1'을 스택에 삽입하고 방문 처리

    [Step 2] 스택의 최상단 노드인 '1'에 방문하지 않은 인접 노드 '2', '3', '8'이 있음
        이중에서 가장 작은 노드인 '2'를 스택에 넣고 방문 처리

    [Step 3] 스택의 최상단 노드인 '2'에 방문하지 않은 인접 노드 '7'이 있음
        따라서 '7'번 노드를 스택에 넣고 방문 처리

    [Step 4] 스택의 최상단 노드인 '7'에 방문하지 않은 인접 노드 '6', '8'이 있음
        이 중에서 가장 작은 노드인 '6'을 스택에 넣고 방문 처리

    [Step 5] 스택의 최상단 노드인 '6'에 방문하지 않은 인접 노드가 없음
        따라서 스택에서 '6'번 노드를 꺼냄

    [Step 6] 스택의 최상단 노드인 '7'에 방문하지 않은 인접 노드 '8'이 있음
        따라서 '8'번 노드를 스택에 넣고 방문 처리

    ```python
    def dfs(graph, v, visited) :
        visited[v] = True
        print(v, end=' ')
        for i in graph[v] :
            if not visited[i] :
                dfs(graph, i, visited)
            
    graph=[[], [2, 3, 8], [1, 7], [1, 4, 5], [3, 5], [3, 4], [7], [2, 6, 8], [1, 7]]

    visited=[False] * 9
    dfs(graph, 1, visited)
    ```

# <mark style='background-color: #ffdce0'> 2. BFS </mark>  
- <mark style='background-color: #fff5b1'>너비 우선 탐색</mark>, 그래프에서 가까운 노드부터 우선적으로 탐색하는 알고리즘
- 스택 자료구조(혹은 재귀 함수)를 이용
    1. 탐색 시작 노드를 스택에 삽입하고 방문 처리
    2. 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문처리
        방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냄
    3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복
- 동작 예시
    [Step 0] 시작 노드 : 1 (방문 기준 : 번호가 낮은 인접 노드부터)

    [Step 1] 시작 노드인 '1'을 스택에 삽입하고 방문 처리

    [Step 2] 스택의 최상단 노드인 '1'에 방문하지 않은 인접 노드 '2', '3', '8'이 있음
        이중에서 가장 작은 노드인 '2'를 스택에 넣고 방문 처리

    [Step 3] 스택의 최상단 노드인 '2'에 방문하지 않은 인접 노드 '7'이 있음
        따라서 '7'번 노드를 스택에 넣고 방문 처리

    [Step 4] 스택의 최상단 노드인 '7'에 방문하지 않은 인접 노드 '6', '8'이 있음
        이 중에서 가장 작은 노드인 '6'을 스택에 넣고 방문 처리

    [Step 5] 스택의 최상단 노드인 '6'에 방문하지 않은 인접 노드가 없음
        따라서 스택에서 '6'번 노드를 꺼냄

    [Step 6] 스택의 최상단 노드인 '7'에 방문하지 않은 인접 노드 '8'이 있음
        따라서 '8'번 노드를 스택에 넣고 방문 처리